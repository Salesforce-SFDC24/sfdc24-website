/*
 * Copyright (c) 2024, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { MultiStageOutput } from '@oclif/multi-stage-output';
import { Lifecycle, Messages } from '@salesforce/core';
import { RequestStatus } from '@salesforce/source-deploy-retrieve';
import terminalLink from 'terminal-link';
import { getZipFileSize } from './output.js';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const mdTransferMessages = Messages.loadMessages('@salesforce/plugin-deploy-retrieve', 'metadata.transfer');
function round(value, precision) {
    const multiplier = Math.pow(10, precision || 0);
    return Math.round(value * multiplier) / multiplier;
}
function formatProgress(current, total) {
    if (total === 0) {
        return '0/0 (0%)';
    }
    return `${current}/${total} (${round((current / total) * 100, 0)}%)`;
}
export class DeployStages {
    mso;
    constructor({ title, jsonEnabled }) {
        this.mso = new MultiStageOutput({
            title,
            stages: [
                'Preparing',
                'Waiting for the org to respond',
                'Deploying Metadata',
                'Running Tests',
                'Updating Source Tracking',
                'Done',
            ],
            jsonEnabled,
            preStagesBlock: [
                {
                    type: 'message',
                    get: (data) => data?.message,
                },
            ],
            postStagesBlock: [
                {
                    label: 'Status',
                    get: (data) => {
                        if (!terminalLink.isSupported)
                            return data?.status;
                        if (!data?.deployUrl)
                            return data?.status;
                        return data?.status
                            ? terminalLink(data.status, data.deployUrl, {
                                fallback: (text, url) => `${text} (${url})`,
                            })
                            : undefined;
                    },
                    bold: true,
                    type: 'dynamic-key-value',
                    onlyShowAtEndInCI: true,
                },
                {
                    label: 'Deploy ID',
                    get: (data) => data?.id,
                    type: 'static-key-value',
                    neverCollapse: true,
                },
                {
                    label: 'Target Org',
                    get: (data) => data?.username,
                    type: 'static-key-value',
                },
                {
                    label: 'Deploy URL',
                    get: (data) => {
                        if (!data?.verbose)
                            return;
                        return data?.deployUrl;
                    },
                    type: 'static-key-value',
                },
                {
                    label: 'Size',
                    get: (data) => data?.deploySize && data?.verbose ? `${getZipFileSize(data.deploySize)} of ~39 MB limit` : undefined,
                    type: 'static-key-value',
                },
                {
                    label: 'Files',
                    get: (data) => data?.deployFileCount && data?.verbose ? `${data.deployFileCount} of 10,000 limit` : undefined,
                    type: 'static-key-value',
                },
            ],
            stageSpecificBlock: [
                {
                    label: 'Components',
                    get: (data) => data?.mdapiDeploy?.numberComponentsTotal
                        ? formatProgress(data?.mdapiDeploy?.numberComponentsDeployed ?? 0, data?.mdapiDeploy?.numberComponentsTotal)
                        : undefined,
                    stage: 'Deploying Metadata',
                    type: 'dynamic-key-value',
                },
                {
                    label: 'Tests',
                    get: (data) => data?.mdapiDeploy?.numberTestsTotal && data?.mdapiDeploy?.numberTestsCompleted
                        ? formatProgress(data?.mdapiDeploy?.numberTestsCompleted, data?.mdapiDeploy?.numberTestsTotal)
                        : undefined,
                    stage: 'Running Tests',
                    type: 'dynamic-key-value',
                },
                {
                    label: 'Members',
                    get: (data) => data?.sourceMemberPolling?.original
                        ? formatProgress(data.sourceMemberPolling.original - data.sourceMemberPolling.remaining, data.sourceMemberPolling.original)
                        : undefined,
                    stage: 'Updating Source Tracking',
                    type: 'dynamic-key-value',
                },
            ],
        });
    }
    start({ username, deploy }, initialData) {
        const lifecycle = Lifecycle.getInstance();
        if (initialData)
            this.mso.updateData(initialData);
        this.mso.skipTo('Preparing', { username, id: deploy.id });
        // for sourceMember polling events
        lifecycle.on('sourceMemberPollingEvent', (event) => {
            if (event.original > 0) {
                return Promise.resolve(this.mso.skipTo('Updating Source Tracking', { sourceMemberPolling: event }));
            }
            return Promise.resolve();
        });
        deploy.onUpdate((data) => {
            if (data.numberComponentsDeployed === data.numberComponentsTotal &&
                data.numberTestsTotal > 0 &&
                data.numberComponentsDeployed > 0) {
                this.mso.skipTo('Running Tests', { mdapiDeploy: data, status: mdTransferMessages.getMessage(data?.status) });
            }
            else if (data.status === RequestStatus.Pending) {
                this.mso.skipTo('Waiting for the org to respond', {
                    mdapiDeploy: data,
                    status: mdTransferMessages.getMessage(data?.status),
                });
            }
            else {
                this.mso.skipTo('Deploying Metadata', {
                    mdapiDeploy: data,
                    status: mdTransferMessages.getMessage(data?.status),
                });
            }
        });
        deploy.onFinish((data) => {
            this.mso.updateData({ mdapiDeploy: data.response, status: mdTransferMessages.getMessage(data.response.status) });
            if (data.response.status === RequestStatus.Failed) {
                this.mso.error();
            }
            else {
                this.mso.skipTo('Done');
                this.mso.stop();
            }
        });
        deploy.onCancel((data) => {
            this.mso.updateData({ mdapiDeploy: data, status: mdTransferMessages.getMessage(data?.status ?? 'Canceled') });
            this.mso.error();
        });
        deploy.onError((error) => {
            if (error.message.includes('client has timed out')) {
                this.mso.updateData({ status: 'Client Timeout' });
            }
            this.mso.error();
            throw error;
        });
    }
    update(data) {
        this.mso.updateData(data);
    }
    stop() {
        this.mso.stop();
    }
    error() {
        this.mso.error();
    }
    done(data) {
        this.mso.skipTo('Done', data);
    }
}
//# sourceMappingURL=deployStages.js.map