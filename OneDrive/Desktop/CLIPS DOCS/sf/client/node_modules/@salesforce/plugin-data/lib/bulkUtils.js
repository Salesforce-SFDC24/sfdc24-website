/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Transform, Readable } from 'node:stream';
import { createInterface } from 'node:readline';
import { pipeline } from 'node:stream/promises';
import * as fs from 'node:fs';
import { EOL } from 'node:os';
import { HttpApi } from '@jsforce/jsforce-node/lib/http-api.js';
import { Parser as csvParse } from 'csv-parse';
import { Messages, SfError } from '@salesforce/core';
import { Duration } from '@salesforce/kit';
import { capitalCase } from 'change-case';
import { getResultMessage } from './reporters/query/reporters.js';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-data', 'messages');
export const setupLifecycleListeners = ({ job, cache, username, apiVersion, cmd, isAsync, endWaitTime, }) => {
    // the event emitted by jsforce's polling function
    job.on('inProgress', (jobInfo) => {
        cmd.spinner.status = formatSpinnerProgress(isAsync, endWaitTime, jobInfo);
    });
    // the event emitted other places in the plugin
    job.on('jobProgress', () => {
        const handler = async () => {
            const jobInfo = await job.check();
            cmd.spinner.status = formatSpinnerProgress(isAsync, endWaitTime, jobInfo);
        };
        handler().catch((err) => eventListenerErrorHandler(err));
    });
    job.on('failed', throwAndStopSpinner(cmd.spinner));
    job.on('error', throwAndStopSpinner(cmd.spinner));
    job.once('jobTimeout', () => {
        const handler = async () => {
            await cache?.createCacheEntryForRequest(job.id ?? '', username, apiVersion);
            displayBulkV2Result({ jobInfo: await job.check(), username, isAsync, cmd });
        };
        handler().catch((err) => eventListenerErrorHandler(err));
    });
};
export const displayBulkV2Result = ({ jobInfo, isAsync, cmd, username = 'unspecified user', }) => {
    // if we just read from jobInfo.operation it may suggest running the nonexistent `sf data hardDelete resume` command
    const operation = jobInfo.operation === 'hardDelete' || jobInfo.operation === 'delete' ? 'delete' : jobInfo.operation;
    if (isAsync && jobInfo.state !== 'JobComplete' && jobInfo.state !== 'Failed') {
        cmd.logSuccess(messages.getMessage('success', [operation, jobInfo.id]));
        cmd.info(messages.getMessage('checkStatus', [operation, jobInfo.id, username]));
    }
    else {
        cmd.log();
        cmd.info(getResultMessage(jobInfo));
        if ((jobInfo.numberRecordsFailed ?? 0) > 0 || jobInfo.state === 'Failed') {
            cmd.info(messages.getMessage('checkJobViaUi', [username, jobInfo.id]));
            process.exitCode = 1;
        }
        if (jobInfo.state === 'InProgress' || jobInfo.state === 'Open') {
            cmd.info(messages.getMessage('checkStatus', [operation, jobInfo.id, username]));
        }
        if (jobInfo.state === 'Failed') {
            throw messages.createError('bulkJobFailed', [jobInfo.id]).setData(jobInfo);
        }
    }
};
const eventListenerErrorHandler = (err) => {
    throw err instanceof Error || typeof err === 'string' ? err : JSON.stringify(err);
};
const throwAndStopSpinner = (spinner) => (err) => {
    try {
        throw err;
    }
    finally {
        spinner.stop();
    }
};
export const getRemainingTimeStatus = ({ isAsync, endWaitTime }) => isAsync ? '' : messages.getMessage('remainingTimeStatus', [Duration.milliseconds(endWaitTime - Date.now()).minutes]);
const formatSpinnerProgress = (isAsync, endWaitTime, jobInfo) => `${getRemainingTimeStatus({
    isAsync,
    endWaitTime,
})} | ${getStage(jobInfo.state)} | ${getRemainingRecordsStatus(jobInfo)}`;
const getStage = (state) => ` Stage: ${capitalCase(state)}`;
const getRemainingRecordsStatus = (jobInfo) => {
    const numberRecordsProcessed = jobInfo.numberRecordsProcessed ?? 0;
    const numberRecordsFailed = jobInfo.numberRecordsFailed ?? 0;
    const numberRecordSucceeded = numberRecordsProcessed - numberRecordsFailed;
    // the leading space is intentional
    return ` ${messages.getMessage('remainingRecordsStatus', [
        numberRecordsProcessed,
        numberRecordSucceeded,
        numberRecordsFailed,
    ])}`;
};
export const POLL_FREQUENCY_MS = 5000;
export const isBulkV2RequestDone = (jobInfo) => ['Aborted', 'Failed', 'JobComplete'].includes(jobInfo.state);
export const transformResults = (results) => ({
    // ensureArray is used to handle the undefined or non-array case
    successfulResults: results.successfulResults.map(anyRecordToBulkProcessedRecordV2),
    failedResults: results.failedResults.map(anyRecordToBulkProcessedRecordV2),
    // if the csv can't be read, it returns a string that is the csv body
    ...(typeof results.unprocessedRecords === 'string'
        ? { unprocessedRecords: [], unparsed: results.unprocessedRecords }
        : { unprocessedRecords: results.unprocessedRecords.map(anyRecordToBulkProcessedRecordV2) }),
});
const anyRecordToBulkProcessedRecordV2 = (record) => record;
/** call the describe to verify the object exists in the org  */
export const validateSobjectType = async (sobjectType, connection) => {
    try {
        await connection.sobject(sobjectType).describe();
        return sobjectType;
    }
    catch (e) {
        throw new Error(messages.getMessage('invalidSobject', [sobjectType, e.message]));
    }
};
/** calculate ms between the "now" time and the endWaitTime */
export const remainingTime = (now) => (endWaitTime) => Math.max((endWaitTime ?? now) - now, 0);
export var ColumnDelimiter;
(function (ColumnDelimiter) {
    ColumnDelimiter["BACKQUOTE"] = "`";
    ColumnDelimiter["CARET"] = "^";
    ColumnDelimiter["COMMA"] = ",";
    ColumnDelimiter["PIPE"] = "|";
    ColumnDelimiter["SEMICOLON"] = ";";
    ColumnDelimiter["TAB"] = "\t";
})(ColumnDelimiter || (ColumnDelimiter = {}));
async function bulkRequest(conn, url) {
    const httpApi = new HttpApi(conn, {
        responseType: 'text/plain', // this ensures jsforce doesn't try parsing the body
    });
    let headers;
    httpApi.on('response', (response) => {
        headers = response.headers;
    });
    const body = await httpApi.request({
        url: conn.normalizeUrl(url),
        method: 'GET',
    });
    if (!headers)
        throw new Error('failed to get HTTP headers for bulk query');
    return {
        body,
        headers,
    };
}
export async function exportRecords(conn, queryJob, outputInfo) {
    let jobInfo;
    queryJob.on('jobComplete', (completedJob) => {
        jobInfo = completedJob;
    });
    await queryJob.poll();
    if (jobInfo === undefined) {
        throw new Error('could not get job info after polling');
    }
    let locator;
    let recordsWritten = 0;
    while (locator !== 'null') {
        // we can't parallelize this because we:
        // 1. need to get 1 batch to know the locator for the next one
        // 2. merge all batches into one csv or json file
        //
        // eslint-disable-next-line no-await-in-loop
        const res = await bulkRequest(conn, locator ? `/jobs/query/${jobInfo.id}/results?locator=${locator}` : `/jobs/query/${jobInfo.id}/results`);
        if (outputInfo.format === 'json') {
            const jsonWritable = fs.createWriteStream(outputInfo.filePath, {
                // Open file for reading and appending. The file is created if it does not exist but fails if the path exists.
                // https://nodejs.org/api/fs.html#file-system-flags
                flags: 'ax+',
            });
            const totalRecords = jobInfo.numberRecordsProcessed;
            if (!locator) {
                // first write, start JSON array
                jsonWritable.write(`[${EOL}`);
            }
            // eslint-disable-next-line no-await-in-loop
            await pipeline(Readable.from(res.body), new csvParse({ columns: true, delimiter: ColumnDelimiter[outputInfo.columnDelimiter] }), new Transform({
                objectMode: true,
                // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
                transform(chunk, _encoding, callback) {
                    if (recordsWritten === totalRecords - 1) {
                        callback(null, `  ${JSON.stringify(chunk)}${EOL}]`);
                    }
                    else {
                        recordsWritten++;
                        callback(null, `  ${JSON.stringify(chunk)},${EOL}`);
                    }
                },
            }), jsonWritable);
        }
        else {
            // csv
            // eslint-disable-next-line no-await-in-loop
            await pipeline(locator
                ? [
                    Readable.from(res.body.slice(res.body.indexOf(EOL) + 1)),
                    fs.createWriteStream(outputInfo.filePath, {
                        flags: 'a', // append mode
                    }),
                ]
                : [Readable.from(res.body), fs.createWriteStream(outputInfo.filePath)]);
        }
        locator = res.headers['sforce-locator'];
    }
    return jobInfo;
}
async function readFirstFiveLines(filePath) {
    const fileStream = fs.createReadStream(filePath);
    const rl = createInterface({
        input: fileStream,
        crlfDelay: Infinity, // Recognizes both CRLF and LF line endings
    });
    const lines = [];
    for await (const line of rl) {
        lines.push(line);
        if (lines.length === 5)
            break;
    }
    return lines;
}
export async function detectDelimiter(filePath) {
    const delimiterMap = new Map();
    delimiterMap.set('`', 'BACKQUOTE');
    delimiterMap.set('^', 'CARET');
    delimiterMap.set(',', 'COMMA');
    delimiterMap.set('|', 'PIPE');
    delimiterMap.set(';', 'SEMICOLON');
    delimiterMap.set('	', 'TAB');
    const delimiters = ['`', '^', ',', '|', ';', '	'];
    const delimiterCounts = {};
    // Initialize counts
    for (const delimiter of delimiters) {
        delimiterCounts[delimiter] = 0;
    }
    // Read the first few lines of the file
    const data = await readFirstFiveLines(filePath);
    data.forEach((line) => {
        // Ignore empty lines
        if (line.trim() === '')
            return;
        delimiters.forEach((delimiter) => {
            // Use regex to avoid counting delimiters inside quotes
            const regexDelimiter = delimiter === '^' || delimiter === '|' ? `\\${delimiter}` : delimiter;
            const regex = new RegExp(`(?<=^|[^"'])${regexDelimiter}(?=[^"']*$)`, 'g');
            const count = (line.match(regex) ?? []).length;
            delimiterCounts[delimiter] += count;
        });
    });
    // Find the delimiter with the highest count
    let detectedDelimiter;
    let maxCount = 0;
    for (const [delimiter, count] of Object.entries(delimiterCounts)) {
        if (count > maxCount) {
            maxCount = count;
            detectedDelimiter = delimiter;
        }
    }
    const columDelimiter = delimiterMap.get(detectedDelimiter ?? '');
    if (columDelimiter === undefined) {
        throw new SfError(`Failed to detect column delimiter used in ${filePath}.`);
    }
    return columDelimiter;
}
//# sourceMappingURL=bulkUtils.js.map